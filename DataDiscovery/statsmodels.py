import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# ignore warnings
import warnings
warnings.filterwarnings("ignore")

# load the data from a csv file
# each csv file contains the coordinates of the body parts of a single animal
# the csv files are generated by the DeepLabCut software
locomotion = pd.read_csv('locomotion_8.csv')
immobility = pd.read_csv('sleeping_945.csv')
nonlocomotion = pd.read_csv('nonlocomotion_150.csv')

fps = 30
width= 1280
height = 1024
time_interval = 1 / fps 

# window size for rolling mean 
window_size = 60 

# smooth categorical data with rolling mean
def rolling_categorical_features(data, window_size= 60):
    map = {'locomotion': 0, 'immobility': 1, 'nonlocomotion': 2}
    data = data.map(map)
    data = data.rolling(window_size, min_periods=1).apply(np.mean).shift(0).astype(int)
    # reverse map 
    map = {0: 'locomotion', 1: 'immobility', 2: 'nonlocomotion'}
    data = data.map(map)
    return data

# smooth numerical data of features with rolling mean
def rolling_features(data, window_size= 60):
        return data.rolling(window_size, min_periods=1).mean().shift(0)


def interior_angle(p0, p1, p2):
    v0 = np.array(p0) - np.array(p1)
    v1 = np.array(p2) - np.array(p1)
    angle = np.math.atan2(np.linalg.det([v0,v1]), np.dot(v0,v1))
    return np.degrees(angle)

# calculate kinematic features for a single coordinate (x or y) for a single csv file
def dataset(data, coordinate='x', behavior=None):
    
    head_centroid = data[['nose_'+coordinate, 'left_ear_'+coordinate, 'right_ear_'+coordinate, 'neck_'+coordinate]].mean(axis=1)
    head_centroid = rolling_features(head_centroid)

    body_centroid = data[['neck_'+coordinate, 'left_side_'+coordinate, 'right_side_'+coordinate, 'tail_base_'+coordinate]].mean(axis=1)
    body_centroid = rolling_features(body_centroid)


    head_velocity = (head_centroid.diff() / time_interval).fillna(np.mean(head_centroid.diff() / time_interval))
    head_velocity = rolling_features(head_velocity)

    body_velocity = (body_centroid.diff() / time_interval).fillna(np.mean(body_centroid.diff() / time_interval))
    body_velocity = rolling_features(body_velocity)

    head_acceleration = (head_velocity.diff() / time_interval).fillna(np.mean(head_velocity.diff() / time_interval))
    head_acceleration = rolling_features(head_acceleration)

    body_acceleration = (body_velocity.diff() / time_interval).fillna(np.mean(body_velocity.diff() / time_interval))
    body_acceleration = rolling_features(body_acceleration)


    head_body_angle_right = []
   
    for i in range(len(data)):
        p0 = [data['right_ear_x'][i], data['right_ear_y'][i]]
        p1 = [data['neck_x'][i], data['neck_y'][i]]
        p2 = [data['right_side_x'][i], data['right_side_y'][i]]
        angle_right = interior_angle(p0, p1, p2)
        head_body_angle_right.append(angle_right)
    head_body_angle_right = rolling_features(pd.Series(head_body_angle_right))

    head_body_angle_left = []
    for i in range(len(data)):
        p0 = [data['left_ear_x'][i], data['left_ear_y'][i]]
        p1 = [data['neck_x'][i], data['neck_y'][i]]
        p2 = [data['left_side_x'][i], data['left_side_y'][i]]
        angle_left = interior_angle(p0, p1, p2)
        head_body_angle_left.append(angle_left)
    head_body_angle_left = rolling_features(pd.Series(head_body_angle_left))
    # make a dataframe
    df = pd.DataFrame({'head_centroid_'+coordinate: head_centroid, 
                       'body_centroid_'+coordinate: body_centroid, 
                       'head_velocity_'+coordinate: head_velocity, 
                       'body_velocity_'+coordinate: body_velocity, 
                       'head_acceleration_'+coordinate: head_acceleration, 
                       'body_acceleration_'+coordinate: body_acceleration, 
                       'head_body_angle_right': head_body_angle_right,
                       'head_body_angle_left': head_body_angle_left})
    
    if behavior:
        df['behavior'] = pd.Series([behavior]*len(df))
        df['behavior'] = rolling_categorical_features(df['behavior'])
    return df 

# compute kinematic features for x coordinate and y coordinate respectively and merge them into a single dataframe
def merge_data(data, behavior=None):
    x = dataset(data, coordinate='x', behavior=None)
    y = dataset(data, coordinate='y', behavior=behavior)
    df = x.merge(y, left_index=True, right_index=True)
    return df

# compute kinematic features for all csv files and concatenate them into a single dataframe
locomotion_df = merge_data(locomotion, behavior='locomotion')
immobility_df = merge_data(immobility, behavior='immobility')
nonlocomotion_df = merge_data(nonlocomotion, behavior='nonlocomotion')
df = pd.concat([locomotion_df, immobility_df, nonlocomotion_df])

# save the dataframe to a csv file
df.to_csv('kinematic_features.csv', index=False)


short = pd.read_csv('short_video.csv')
short = merge_data(short)
df = short
# split the dataframe into features and labels
X = df.iloc[:, :-1] # numerical features
#y = df.iloc[:, -1] # categorical feature

#print(y.value_counts())

#color = {'locomotion': 'r', 'immobility': 'b', 'nonlocomotion': 'g'}
#y = y.map(color)
######################### UMAP ############################
import umap.umap_ as umap
reducer = umap.UMAP(n_components=3)
X_umap = reducer.fit_transform(X) #UMAP embedding
# Create a 2D scatter plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(X_umap[:,0], X_umap[:,1], X_umap[:, 2])
ax.set_xlabel('UMAP1')
ax.set_ylabel('UMAP2')
ax.set_zlabel('UMAP3')
plt.show()

# # Use HDBSCAN to cluster the data
# import hdbscan
# umap_embeddings = X_umap 
# clusterer = hdbscan.HDBSCAN()
# fig = plt.figure()
# ax = fig.add_subplot(111, projection='3d')
# cluster_labels = clusterer.fit_predict(umap_embeddings)
# cluster_labels = clusterer.fit_predict(umap_embeddings)
# ax.scatter(X_umap[:,0], X_umap[:,1], X_umap[:, 2], c=cluster_labels, cmap='Spectral')
# ax.set_xlabel('UMAP1')
# ax.set_ylabel('UMAP2')
# ax.set_zlabel('UMAP3')
# plt.show()

# Use KNN to cluster the data
from sklearn.cluster import KMeans
kmeans = KMeans(n_clusters=2, random_state=0).fit(X_umap)
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(X_umap[:,0], X_umap[:,1], X_umap[:, 2], c=kmeans.labels_, cmap='Spectral')
ax.set_xlabel('UMAP1')
ax.set_ylabel('UMAP2')
ax.set_zlabel('UMAP3')
plt.show()

# add the cluster labels to the dataframe
df['cluster'] = kmeans.labels_
# save the dataframe to a csv file
df.to_csv('clustered_kinematic_features.csv', index=False)

df = pd.read_csv('clustered_kinematic_features.csv')
# roll the cluster labels
df['cluster'] = rolling_features(df['cluster'], window_size=300).astype(int)

# map the cluster labels to the videos
import cv2
cap = cv2.VideoCapture("C:\\Users\\chang\\DeepLabCut\\main\\JUPYTER\\DLC_Data\\video_13-57-19\\short_video.mp4")
font = cv2.FONT_HERSHEY_SIMPLEX
text_color = (255, 255, 255)
text_size = 1
text_thickness = 2

while True:
    ret, frame = cap.read()
    if ret:
        frame_number = int(cap.get(cv2.CAP_PROP_POS_FRAMES))
        cv2.putText(frame, 'cluster: {}'.format(df['cluster'][frame_number]), (10, 50), font, text_size, text_color, text_thickness)
        cv2.imshow('frame', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
                break
    else:
        break

cap.release()
cv2.destroyAllWindows()
